from __future__ import annotations

import struct
from dataclasses import dataclass
from pathlib import Path

NAME = 'd-link dcs'
MIME_PATTERNS = ['firmware/dlink-dcs', 'firmware/dlink-dcs-enc']
VERSION = '0.1.0'

# loosely based on the "D-Link Firmware unpacker V1.0" from http://www.hardwarefetish.com

HEADER_MAGIC = 0xAA7EC55B
HEADER_SIZE = 0x10
SECTION_HEADER_MAGIC = 0xA55A
SECTION_HEADER_SIZE = 0x40
# fmt: off
RANDOM_TABLES = [
    [
        0x544f, 0x602b, 0xfd2b, 0x0983, 0x8ec1, 0x020d, 0x1631, 0x5e6e, 0x3e86, 0x87c4, 0xcfbc, 0x15fb, 0xe290, 0x287b,
        0x1693, 0xe07b, 0xcfa2, 0xae13, 0xd3d6, 0xe7b9, 0x9d8a, 0x0117, 0x3283, 0x845f, 0xcb19, 0x1d44, 0x9050, 0xacfd,
        0xbc8b, 0xf759, 0x8a50, 0xa557, 0x8b00, 0xdbf8, 0x0357, 0xe646, 0x898a, 0xc504, 0x9030, 0x148c, 0x394d, 0x0c71,
        0xde04, 0x4862, 0x8869, 0x8114, 0x9c59, 0x2b88, 0x83a4, 0x03ac, 0x7fc6, 0xcdb2, 0xf140, 0xdec6, 0x258e, 0x68de,
        0x8f8e, 0x6a62, 0x6958, 0x9896, 0x8d38, 0x472d, 0x926a, 0xe4bd, 0xcea9, 0x413e, 0x3e87, 0x24b0, 0xfac7, 0x6334,
        0xedc1, 0x4790, 0xc32a, 0x184a, 0x7c77, 0x3f10, 0x4de3, 0xac4d, 0xb71d, 0xbd0b, 0x1c7d, 0x4367, 0xdf3a, 0xa142,
        0xcdaa, 0x5145, 0x7d9c, 0x29b5, 0x6f24, 0x3b79, 0x16c8, 0x48e0, 0x2e2a, 0x54b7, 0x8122, 0x4950, 0x4a71, 0x6c26,
        0xc185, 0x90b5, 0x23df, 0x03ca, 0x84ca, 0x5286, 0xcf91, 0x54bd, 0x3e1b, 0xe9f0, 0x548f, 0x01b4, 0xfb78, 0x0489,
        0x3098, 0x6637, 0x1a4f, 0x52c7, 0x6bf9, 0x2468, 0x28f8, 0x26a1, 0xb366, 0x9345, 0xc306, 0x0d0d, 0x9478, 0x30a5,
        0x2ae2, 0xb26e, 0xf14f, 0x58eb, 0xf6a0, 0x40ab, 0x0832, 0x2fee, 0x47ad, 0xa440, 0xd028, 0xd245, 0xe1b5, 0xd934,
        0x807e, 0x08b2, 0xb241, 0x649b, 0xc366, 0x780d, 0x6bde, 0x9ae3, 0xf0fa, 0xe05b, 0x6d01, 0xd7dd, 0x271d, 0x9c84,
        0xb16e, 0x6f1a, 0x61ae, 0x0fcd, 0x4d05, 0x877a, 0x3435, 0x9029, 0xbba1, 0x90e4, 0x1394, 0xafd3, 0xe8a8, 0x9041,
        0x2d95, 0x3ee2, 0x1dfa, 0x0197, 0x9b10, 0x63b8, 0xdaaf, 0x0afb, 0x084a, 0x920a, 0x715b, 0xacc1, 0x26e2, 0x32d9,
        0xd022, 0xb983, 0x63e2, 0x350d, 0x751a, 0x310c, 0x915f, 0x16a3, 0x640b, 0x7910, 0x5b49, 0x4c29, 0xbe79, 0x1b62,
        0x4879, 0xfaa6, 0x5f20
    ],
    [
        0xb4b0, 0x3826, 0x75bd, 0xc284, 0xf1bb, 0xa5f9, 0x5bf0, 0x1633, 0xc980, 0x187a, 0x75ca, 0xc8c5, 0x829d, 0x9264,
        0x44a4, 0xb89d, 0xc386, 0xfe32, 0x9277, 0x6117, 0xbdce, 0x2f57, 0xa99f, 0x90a3, 0x2461, 0x8848, 0x855c, 0x7d00,
        0xec42, 0x7b83, 0x4ee5, 0x7255, 0x4508, 0x95c1, 0x67b8, 0x6462, 0x6819, 0x90ca, 0xadf7, 0x037b, 0xdbe7, 0xf060,
        0x3a9f, 0x8f23, 0xb527, 0x50e2, 0x191e, 0xa60c, 0x6077, 0xda34, 0xf6c2, 0xcce4, 0xd82a, 0x7103, 0x8ee9, 0x2fea,
        0x282a, 0x62e4, 0x7a4d, 0xe7cf, 0x8fc6, 0x9b91, 0x08c2, 0x23b0, 0x5e31, 0x41dd, 0x7975, 0x99e8, 0x0346, 0xf58b,
        0xcb82, 0x0d8c, 0x974a, 0xd7c0, 0xea11, 0x7bd3, 0x5905, 0xd2ce, 0xf0be, 0xe8db, 0xdfa5, 0x9822, 0x861e, 0xc92e,
        0x3884, 0x67a6, 0xc67b, 0x3211, 0xbbed, 0x1367, 0xc8bf, 0x1815, 0xdc57, 0x2220, 0x6d64, 0x4d27, 0x555f, 0xb538,
        0x346e, 0x8744, 0x5865, 0xd153, 0xe3b2, 0x1e0e, 0xd7f2, 0xbf62, 0xa880, 0x5e56, 0xa093, 0x4ae0, 0x19d0, 0x5197,
        0x3465, 0xce90, 0x4864, 0x1e48, 0x0799, 0x613e, 0x6338, 0x9024, 0xa3c4, 0x1d16, 0xdb98, 0xaefa, 0x6e98, 0x165f,
        0xcd40, 0x9296, 0xfa36, 0xd010, 0x48bd, 0x65fa, 0xd002, 0x1d8e, 0x52aa, 0xd956, 0xea53, 0x2c8d, 0x464f, 0x7d85,
        0x48cc, 0x8ec1, 0xfcfb, 0xaf90, 0xae30, 0x17be, 0x9cbb, 0x8768, 0xa61f, 0xd112, 0x46ef, 0x3882, 0x1dca, 0x7326,
        0xb8df, 0x5d05, 0xb824, 0x54c1, 0x017a, 0x45bc, 0x57b0, 0xbb56, 0x98d9, 0x5915, 0xe786, 0x1c22, 0x410a, 0xa0b8,
        0x1a11, 0xf63b, 0xcf9f, 0xb5bc, 0x565b, 0x9d39, 0x32ee, 0xd72a, 0xc219, 0xe0c8, 0x8df5, 0x5bd7, 0xe0bc, 0x2502,
        0xa53b, 0x2f29, 0x478b, 0x0cb9, 0x5b8d, 0xd111, 0xb2d9, 0x8ba6, 0x446c, 0x3b28, 0x145f, 0x0fe4, 0xa39f, 0x2a84,
        0x7d68, 0xd248, 0xbc9e, 0xa6d8, 0xfb22, 0x5ddc, 0x0d37, 0x60dc, 0x09b4, 0x1144, 0x66a9, 0x3d6c, 0x20ee, 0xc5fc,
        0xa7e5
    ],
    [
        0xa14e, 0x8a22, 0x69fc, 0xa0d6, 0x1d08, 0x4bd4, 0x2e02, 0x22f8, 0xae4d, 0x8505, 0xb785, 0x95da, 0x4e07, 0x96cf,
        0x0b14, 0x4a69, 0x4294, 0x0e02, 0xb4a8, 0xb50d, 0x3581, 0x4025, 0x96e7, 0xea03, 0x193e, 0x5689, 0xa20b, 0x0ac8,
        0x44d8, 0xb7a4, 0x7c0c, 0x6b44, 0xbca4, 0x6b2e, 0x8978, 0x5c93, 0x3020, 0x3a58, 0xfca9, 0x5d53, 0x4283, 0x3111,
        0x7448, 0x0fe4, 0x4502, 0x0282, 0xd733, 0x0af4, 0x8fe2, 0x0eb9, 0x3d27, 0x4646, 0xcd80, 0x56e8, 0xafa7, 0x699d,
        0x2a57, 0xcc8c, 0xf18b, 0xec4d, 0x0117, 0xf0f5, 0xdaf7, 0x4099, 0xdec1, 0xe10d, 0x224e, 0x8dc7, 0x9e8b, 0x9dda,
        0x6c75, 0x5e68, 0x5009, 0x67e3, 0xeb33, 0x1869, 0xe743, 0x3d00, 0xa003, 0xf000, 0xce9c, 0x6004, 0xb5a4, 0x1942,
        0x35d2, 0xe629, 0x043d, 0xdd44, 0x319b, 0x78ea, 0x4cf7, 0xb5cc, 0xeebd, 0xa489, 0x7b88, 0x4aa0, 0x08f8, 0x1b34,
        0x554a, 0x24a6, 0x3a2c, 0x449d, 0x01ec, 0x091b, 0x29a2, 0x6ffd, 0xa4a6, 0x93c3, 0x2e20, 0xcb87, 0x0121, 0x7be2,
        0xaee9, 0x39ab, 0x1602, 0x619e, 0xa2b6, 0x9962, 0xc000, 0x516c, 0x972a, 0x93d5, 0x881e, 0x008a, 0xb580, 0x86c4,
        0xc808, 0x435f, 0x1cdf, 0xa0b0, 0xe523, 0xd429, 0x6a73, 0x69ed, 0x6067, 0x16f3, 0x5a8d, 0x8beb, 0x2791, 0x0793,
        0xd04d, 0xab94, 0xfc53, 0xfc18, 0x6662, 0x91b3, 0xe0d4, 0x87f6, 0xadf3, 0x263a, 0x5a00, 0xc7f8, 0x3732, 0x617d,
        0x45a0, 0x6f90, 0x6567, 0x908e, 0x2c0d, 0x0760, 0xb61d, 0x9412, 0x5e6c, 0x9fb2, 0x8322, 0x3db1, 0x3340, 0x588d,
        0x4a7e, 0xd437, 0xdd42, 0x99e9, 0x02e9, 0x5cf3, 0x1b24, 0xe629, 0x7340, 0x7ede, 0xe8c2, 0xa216, 0x2237, 0xc020,
        0xe72c, 0xd407, 0xa443, 0xafb2, 0xc6f5, 0x8c85, 0xbd1e, 0x7025, 0x16cb, 0xf659, 0x8b15, 0xf215, 0x132e, 0x8915,
        0xb2e8, 0xc14c, 0x64c4, 0x7a05, 0x18a1, 0xc764, 0x96d0, 0x986c, 0xa135, 0x2cda, 0xfd78, 0x9758, 0x28d7, 0x6b18,
        0xb48c, 0xc828, 0xae1e, 0x1e9e, 0x230d, 0xd1bc, 0x4b6e, 0x6724, 0xe367, 0x8baa, 0x5a2f, 0x770c, 0xff26
    ],
]
# fmt: on
SECTION_TYPES = {
    0: 'AUTO',
    1: 'JFFS2',
    2: 'YAFFS',
    3: 'NONE',
}


class RandomNumberGenerator:
    def __init__(self):
        self._state = [0] * 3

    def _get_rand(self, index: int) -> int:
        result = RANDOM_TABLES[index][self._state[index]]
        self._state[index] = (self._state[index] + 1) % len(RANDOM_TABLES[index])
        return result

    def get_random(self) -> int:
        return self._get_rand(0) ^ self._get_rand(1) ^ self._get_rand(2)


@dataclass
class DlinkDcsHeader:
    filesize: int
    checksum: int
    payload_key: int
    section_count: int
    header_key: int

    @classmethod
    def from_bytes(cls, data: bytes, key: int) -> DlinkDcsHeader:
        size, checksum, payload_key, section_count, header_key = struct.unpack('<IHHHH', data)
        return cls(
            size ^ _pad_key(key),
            checksum ^ key,
            payload_key ^ key,
            section_count ^ key,
            header_key ^ key,
        )

    def __str__(self):
        return (
            f'====== Header ======\n'
            f'size: {self.filesize:,} bytes\n'
            f'checksum: 0x{self.checksum:x}\n'
            f'payload key: 0x{self.payload_key:x}\n'
            f'section count: {self.section_count}\n'
            f'header key: 0x{self.header_key:x}'
        )


@dataclass
class SectionHeader:
    magic: int
    mtd: int
    section_type: int
    size: int
    offset: int
    padding: bytes

    @classmethod
    def from_bytes(cls, data: bytes) -> SectionHeader:
        values = struct.unpack('<HBBII52s', data)
        return cls(*values)

    def __str__(self):
        return (
            f'mtd: 0x{self.mtd:x}\n'
            f'section_type: 0x{self.section_type:x} ({SECTION_TYPES.get(self.section_type, "unknown")})\n'
            f'size: {self.size:,} bytes\n'
            f'offset: 0x{self.offset:x}'
        )


def unpack_function(file_path: str, tmp_dir: str) -> dict:
    with Path(file_path).open(mode='rb') as fp:
        encoded_magic = struct.unpack('<I', fp.read(4))[0]
        key = _derive_key(encoded_magic)
        header = DlinkDcsHeader.from_bytes(fp.read(12), key)
        # the key should be stored in the last field (in the XOR encrypted file it should be 0)
        assert header.header_key == key, 'sanity check for machine code failed'
        payload = _decrypt_payload(fp.read(), header.payload_key ^ header.header_key)
        dump_log = _dump_sections(payload, header, Path(tmp_dir))
    return {'output': str(header) + dump_log}


def _derive_key(encoded_magic) -> int:
    key_full = encoded_magic ^ HEADER_MAGIC
    key_lower = key_full & 0xFFFF
    key_upper = (key_full >> 16) & 0xFFFF
    assert key_lower == key_upper, f'sanity check for encryption key failed: {key_full:x}'
    return key_lower


def _pad_key(key: int) -> int:
    # pad 16-bit key to 32 bits
    return (key << 16) ^ key


def _decrypt_payload(data: bytes, key: int) -> bytes:
    if len(data) % 2 != 0:
        # length must be even => pad with zero if odd
        data += b'\x00'
    rng = RandomNumberGenerator()
    result = bytearray(len(data))
    for i in range(0, len(data), 2):
        decoded = rng.get_random() ^ key ^ struct.unpack_from('<H', data, i)[0]
        struct.pack_into('<H', result, i, decoded)
    return bytes(result)


def _dump_sections(payload: bytes, header: DlinkDcsHeader, output_dir: Path) -> str:
    data_offset = header.section_count * SECTION_HEADER_SIZE
    log = ''
    for idx in range(header.section_count):
        section_header_offset = idx * SECTION_HEADER_SIZE
        section_header = SectionHeader.from_bytes(
            payload[section_header_offset : section_header_offset + SECTION_HEADER_SIZE]
        )
        assert section_header.magic == SECTION_HEADER_MAGIC, 'wrong section magic'
        assert section_header.size < header.filesize

        output_file = output_dir / f'section_{idx:03d}'
        output_file.write_bytes(payload[data_offset : data_offset + section_header.size])
        data_offset += section_header.size
        log += f'\n\n====== Section {idx} ======\n' + str(section_header) + f'\nsaved as {output_file.name}'
    return log


# ----> Do not edit below this line <----
def setup(unpack_tool):
    for item in MIME_PATTERNS:
        unpack_tool.register_plugin(item, (unpack_function, NAME, VERSION))
